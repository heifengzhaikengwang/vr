<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>地球自转演示 - 统一字号标注</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
        }
        button {
            padding: 8px 16px;
            margin: 0 5px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            transition: background 0.3s;
        }
        button:hover { 
            background: #2980b9; 
        }
        button:active {
            background: #1c5980;
        }
        .slider-container {
            display: inline-block;
            margin: 0 10px;
            color: white;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            font-family: Arial, sans-serif;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-shadow: 0 0 10px #4da6ff;
            z-index: 200;
        }
        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            margin: 10px auto;
            overflow: hidden;
        }
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s;
        }
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5555;
            font-family: Arial, sans-serif;
            font-size: 20px;
            text-align: center;
            display: none;
            z-index: 300;
        }
        #error-message button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="slider-container">
            <label for="speed">自转速度:</label>
            <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1">
        </div>
        <button id="toggleRotation">暂停自转</button>
        <button id="resetView">重置视角</button>
        <button id="toggleAxis">隐藏地轴</button>
        <button id="toggleGrid">隐藏经纬线</button>
    </div>
    
    <div id="loading">
        <div>正在加载地球数据...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="progress-bar"></div>
        </div>
    </div>
    
    <div id="error-message">
        <div>⚠️ 资源加载失败</div>
        <div>请尝试刷新页面或检查网络连接</div>
        <button id="retry-button">重试加载</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x07071a);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 800);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 400;
        controls.maxDistance = 2000;
        
        // 辅助函数：数字转中文数字
        function getChineseNumber(num) {
            const chineseNumbers = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'];
            return chineseNumbers[num] || num.toString();
        }
        
        // ==========================================
        // 城市标记牢固附着在地球表面
        // ==========================================
        const earthRadius = 200;
        function createCityMarker(cityName, lat, lng, color = 0xff0000) {
            // 修正坐标计算（匹配Three.js坐标系）
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;
            
            const x = -earthRadius * 1.01 * Math.sin(phi) * Math.cos(theta);
            const y = earthRadius * 1.01 * Math.cos(phi);
            const z = earthRadius * 1.01 * Math.sin(phi) * Math.sin(theta);
            
            // 创建地表圆点
            const dotGeometry = new THREE.SphereGeometry(6, 12, 12);
            const dotMaterial = new THREE.MeshBasicMaterial({ color: color });
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            dot.position.set(x, y, z);
            earthGroup.add(dot);

            // 创建文字标签 (统一为40px)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.font = 'bold 40px Arial'; // 统一字号
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.strokeStyle = '#000000';
            context.lineWidth = 3;
            context.fillStyle = '#ffff00'; // 黄色文字
            context.strokeText(cityName, canvas.width / 2, canvas.height / 2);
            context.fillText(cityName, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(80, 35, 1);
            sprite.position.set(x * 1.15, y * 1.15 + 15, z * 1.15);
            earthGroup.add(sprite);
            
            return { dot, sprite };
        }
        
        // ==========================================
        // 创建赤道时区与经度标注 - 紧贴地球表面
        // ==========================================
        function createEquatorLabel(text, lng, heightOffset = 0, color = 0x00ff00, fontSize = 40, isVertical = true) {
            // 赤道纬度为0
            const phi = (90 - 0) * Math.PI / 180; // 纬度0
            const theta = (lng + 180) * Math.PI / 180;
            
            // 优化：将标注紧贴地球表面，使用1.015的倍数而不是1.2
            const x = -earthRadius * 1.015 * Math.sin(phi) * Math.cos(theta);
            const y = earthRadius * 1.015 * Math.cos(phi);
            const z = earthRadius * 1.015 * Math.sin(phi) * Math.sin(theta);
            
            // 创建文字画布
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // 根据文字方向设置画布大小
            if (isVertical) {
                canvas.width = 128;
                canvas.height = 256; // 竖排需要更高画布以适应大字号
            } else {
                canvas.width = 256; // 横排增加宽度
                canvas.height = 80; // 横排增加高度
            }
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.strokeStyle = '#000000';
            context.lineWidth = 2;
            
            if (isVertical) {
                // 竖排文字：逐字换行
                const chars = text.split('');
                const lineHeight = fontSize + 4;
                chars.forEach((char, index) => {
                    const y = canvas.height / 2 - (chars.length - 1) * lineHeight / 2 + index * lineHeight;
                    context.strokeText(char, canvas.width / 2, y);
                    context.fillText(char, canvas.width / 2, y);
                });
            } else {
                // 横排文字
                context.strokeText(text, canvas.width / 2, canvas.height / 2);
                context.fillText(text, canvas.width / 2, canvas.height / 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            
            if (isVertical) {
                sprite.scale.set(30, 60, 1); // 竖排缩放调整
            } else {
                sprite.scale.set(60, 30, 1); // 横排缩放调整
            }
            
            // 优化：将标注紧贴地球表面
            sprite.position.set(x, y + heightOffset, z);
            earthGroup.add(sprite);
            
            return sprite;
        }

        // ==========================================
        // 太阳设置
        // ==========================================
        const sunDistance = 600;
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(sunDistance, 0, 0);
        scene.add(sunLight);
        
        const sunGeometry = new THREE.SphereGeometry(100, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffee00,
            emissive: 0xff8800,
            emissiveIntensity: 0.5
        });
        const sunIndicator = new THREE.Mesh(sunGeometry, sunMaterial);
        sunIndicator.position.set(sunDistance, 0, 0);
        scene.add(sunIndicator);
        
        const sunGlowGeometry = new THREE.SphereGeometry(120, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffcc00,
            transparent: true,
            opacity: 0.3
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sunGlow.position.set(sunDistance, 0, 0);
        scene.add(sunGlow);
        
        // 创建地球组
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);
        
        // 创建地轴
        const axisMaterial = new THREE.LineBasicMaterial({ color: 0xff4444, linewidth: 2 });
        const axisGeometry = new THREE.BufferGeometry();
        const axisExtension = earthRadius * 1.5;
        const axisPoints = [
            new THREE.Vector3(0, axisExtension, 0),
            new THREE.Vector3(0, -axisExtension, 0)
        ];
        axisGeometry.setFromPoints(axisPoints);
        const axis = new THREE.Line(axisGeometry, axisMaterial);
        earthGroup.add(axis);

        // 添加极点标记
        const poleGeometry = new THREE.SphereGeometry(8, 16, 16);
        const northPoleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const southPoleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        
        const northPole = new THREE.Mesh(poleGeometry, northPoleMaterial);
        northPole.position.set(0, earthRadius, 0);
        earthGroup.add(northPole);
        
        const southPole = new THREE.Mesh(poleGeometry, southPoleMaterial);
        southPole.position.set(0, -earthRadius, 0);
        earthGroup.add(southPole);
        
        // 添加北京
        createCityMarker('北京', 39.9, 116.4, 0xff5555);
        
        // 添加卡塔尔
        createCityMarker('卡塔尔', 25.276987, 51.522152, 0x55ff55);
        
        // 添加中文时区标注 - 放在两条经线中间位置，紧贴地球表面
        for (let i = 1; i <= 12; i++) {
            // 东时区 (1-12)
            const eastLng = i * 15 - 7.5; // 位于两条经线中间
            createEquatorLabel(`东${getChineseNumber(i)}区`, eastLng, 6, 0x00ff00, 40, true);
            
            // 西时区 (1-12)
            const westLng = -i * 15 + 7.5; // 位于两条经线中间
            createEquatorLabel(`西${getChineseNumber(i)}区`, westLng, 6, 0x00ff00, 40, true);
        }
        
        // 0时区特殊标注 (本初子午线)
        createEquatorLabel(`零时区`, -7.5, 6, 0x00ff00, 40, true); // 位于352.5°E和7.5°E之间
        
        // 180°国际日期变更线特殊标注
        createEquatorLabel(`日界线`, 172.5, 6, 0x00ff00, 40, true); // 位于165°E和180°E之间

        // ==========================================
        // 银河背景 - 简化实现
        // ==========================================
        const starCount = 2000;
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 10000;
            starPositions[i + 1] = (Math.random() - 0.5) * 10000;
            starPositions[i + 2] = (Math.random() - 0.5) * 10000;
        }
        
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            sizeAttenuation: true
        });
        
        const stars = new THREE.Points(starsGeometry, starMaterial);
        scene.add(stars);
        
        // ==========================================
        // 昼夜效果（无晨昏线）
        // ==========================================
        const dayNightGeometry = new THREE.SphereGeometry(earthRadius + 0.5, 32, 32);
        const dayNightMaterial = new THREE.MeshBasicMaterial({
            color: 0x222255,
            transparent: true,
            opacity: 0.55,
            side: THREE.BackSide
        });
        const dayNightSphere = new THREE.Mesh(dayNightGeometry, dayNightMaterial);
        scene.add(dayNightSphere);
        
        // ==========================================
        // 创建24条绿色实线经线 + 经度标注
        // ==========================================
        function createEarthGrid() {
            const gridGroup = new THREE.Group();
            
            // 创建24条经线，间隔15度，全部使用绿色实线
            for (let m = 0; m < 24; m++) {
                const angle = (m / 24) * Math.PI * 2;
                const lineGeometry = new THREE.BufferGeometry();
                const linePositions = [];
                
                // 每条经线由多个点组成
                for (let i = 0; i <= 32; i++) {
                    const phi = (i / 32) * Math.PI;
                    const x = earthRadius * 1.01 * Math.sin(phi) * Math.cos(angle);
                    const y = earthRadius * 1.01 * Math.cos(phi);
                    const z = earthRadius * 1.01 * Math.sin(phi) * Math.sin(angle);
                    
                    linePositions.push(x, y, z);
                }
                
                lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, // 绿色实线
                    linewidth: 1.5
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                gridGroup.add(line);
                
                // 为每条经线添加经度标注 - 紧贴地球表面
                const longitude = m * 15;
                let label = "";
                if (longitude === 0) {
                    label = "0°";
                } else if (longitude === 180) {
                    label = "180°";
                } else if (longitude < 180) {
                    label = `${longitude}°E`;
                } else {
                    label = `${360 - longitude}°W`;
                }
                
                // 在赤道下方添加经度标注，使用黄色，横排，紧贴地球 (字号设为40)
                createEquatorLabel(label, longitude, -6, 0xffff00, 40, false);
            }
            
            return gridGroup;
        }
        
        const earthGrid = createEarthGrid();
        earthGroup.add(earthGrid);

        // 控制变量
        let isRotating = true;
        let rotationSpeed = 0.01;
        let gridVisible = true;
        
        // 地球材质加载成功标志
        let earthLoaded = false;
        
        // 交互控件
        document.getElementById('speed').addEventListener('input', function(e) {
            rotationSpeed = parseFloat(e.target.value) * 0.01;
        });
        
        document.getElementById('toggleRotation').addEventListener('click', function(e) {
            isRotating = !isRotating;
            e.target.textContent = isRotating ? '暂停自转' : '开始自转';
        });
        
        document.getElementById('resetView').addEventListener('click', function() {
            camera.position.set(0, 0, 800);
            camera.lookAt(0, 0, 0);
            controls.reset();
        });
        
        document.getElementById('toggleAxis').addEventListener('click', function(e) {
            const showAxis = !axis.visible;
            axis.visible = showAxis;
            northPole.visible = showAxis;
            southPole.visible = showAxis;
            e.target.textContent = showAxis ? '隐藏地轴' : '显示地轴';
        });
        
        document.getElementById('toggleGrid').addEventListener('click', function(e) {
            gridVisible = !gridVisible;
            earthGrid.visible = gridVisible;
            e.target.textContent = gridVisible ? '隐藏经纬线' : '显示经纬线';
        });
        
        // 重试按钮
        document.getElementById('retry-button').addEventListener('click', function() {
            document.getElementById('error-message').style.display = 'none';
            initEarth();
        });
        
        // 窗口大小变化处理
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 创建基本地球 - 当纹理加载失败时使用
        function createBasicEarth() {
            console.log("使用基础地球材质");
            
            const earthGeometry = new THREE.SphereGeometry(earthRadius, 32, 32);
            const earthMaterial = new THREE.MeshBasicMaterial({
                color: 0x2233ff,
                emissive: 0x112244,
            });
            
            const earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);
            
            earthLoaded = true;
            return earth;
        }
        
        // 初始化地球 - 尝试加载纹理地球
        function initEarth() {
            // 创建地球
            const earthGeometry = new THREE.SphereGeometry(earthRadius, 32, 32);
            
            // 设置加载管理器
            const loadingManager = new THREE.LoadingManager();
            const progressBar = document.getElementById('progress-bar');
            
            loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
                const progress = (itemsLoaded / itemsTotal) * 100;
                progressBar.style.width = `${progress}%`;
            };
            
            loadingManager.onLoad = function() {
                document.getElementById('loading').style.display = 'none';
                earthLoaded = true;
                console.log("地球资源加载完成");
            };
            
            loadingManager.onError = function(url) {
                console.error('资源加载失败:', url);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
                // 回退到基础地球
                createBasicEarth();
            };
            
            // 加载地球纹理
            const textureLoader = new THREE.TextureLoader(loadingManager);
            
            // 精简版地球纹理 (避免大图加载失败)
            const earthTexture = textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                function(texture) {
                    console.log("地球纹理加载成功");
                },
                undefined,
                function(error) {
                    console.error('地球纹理加载失败:', error);
                }
            );
            
            const bumpMap = textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_normal_2048.jpg',
                undefined,
                undefined,
                function(error) {
                    console.error('法线贴图加载失败:', error);
                }
            );
            
            const specularMap = textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_specular_2048.jpg',
                undefined,
                undefined,
                function(error) {
                    console.error('高光贴图加载失败:', error);
                }
            );
            
            // 创建地球材质 - 删除specular和shininess属性
            const earthMaterial = new THREE.MeshBasicMaterial({
                map: earthTexture,
                bumpMap: bumpMap,
                bumpScale: 2,
            });
            
            const earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);
        }
        
        // 初始化地球
        initEarth();
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 地球自转
            if (isRotating && earthLoaded) {
                earthGroup.rotation.y += rotationSpeed;
                dayNightSphere.rotation.y += rotationSpeed;
            }
            
            // 更新太阳与昼夜效果相对位置
            const time = Date.now() * 0.0001;
            sunLight.position.x = sunDistance * Math.cos(time * 0.1);
            sunLight.position.z = sunDistance * Math.sin(time * 0.1);
            sunIndicator.position.copy(sunLight.position);
            sunGlow.position.copy(sunLight.position);
            
            // 更新昼夜球体方向
            dayNightSphere.quaternion.copy(earthGroup.quaternion);
            
            // 更新控制器
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 开始动画
        animate();
    </script>
</body>
</html>
